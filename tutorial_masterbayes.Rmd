---
title: "MasterBayes Improved Tutorial"
author: "BIO Class"
date: "Fall 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

We are trying to make a MasterBayes tutorial that doesn't suck.

First step - Read in the data.
One dataset with Genotypic data, one with Phenotypic data.
Also, load MasterBayes:

```{r read data,  message = FALSE, results = 'hide', warning = FALSE}
# Genotypic data
guppyG <- read.table(file = "sim_guppyGeno.txt", header = TRUE)

# Phenotypic data
guppyP <- read.table(file = "sim_guppyPheno.txt", header = TRUE)
## tell R how to interpret certain variables (e.g., integers as factors, etc.)
guppyP <- within(guppyP, {
  id <- as.factor(id)
  color <- as.factor(id)
})


library(MasterBayes)

```

# 1) Making ``VarPed`` (Pedigree Variable) objects
### The first thing you want to do is toss out any individuals you don't want to consider as parents.

Here, we're focusing on the "offspring" variable (``x = offspring``).
We don't care what the gender is ``(gender = NULL)``.
Relational would give us a difference between values, which we don't care about here. 
We just want to exclude individuals that have the value 0 in the offspring column (``restrict = 0``), since members of the offspring generation couldn't have been parents.

```{r ExcludeOffspring}
ExcludeOffspring_Var <- expression(varPed(x = "offspring", gender = NULL,
	relational = FALSE, restrict = 0))
```

### Now we want to make a new variable to figure out how distance between a parent and an offspring impacts the probability of parentage.

So, we tell it we're interested in the distance variable (``x = "distance"``). 
We don't care if it's mom or dad (``gender = NULL``). 
When ``relational = offspring`` it means we're looking for the difference in values between the likely dad/mom and the focal offspring individual.

```{r MakeDistanceVar}
Parentage_Distance_Var <- expression(varPed(x = "distance", gender = NULL,
	relational = "OFFSPRING"))
```

# 2) Making ``PdataPed`` and ``GdataPed`` objects

### Now, we are going to make PdataPed object - This has phenotypic data to give the MCMC, and we're defining a model.
Our model of interest is estimating how distance between offspring and potential parents impacts probability of parentage. 
Our ``pdP`` is going to exclude offspring (``ExcludeOffspring_Var``) and see how distance impacts parentage (``Parentage_Distance_Variable``). 
Then we show it the Phenotypic data frame and say there are unsampled dams and sires out there.

```{r MakePdataPed}
pdP <- PdataPed(formula = list(ExcludeOffspring_Var, Parentage_Distance_Var), data = guppyP,
  USsire = TRUE, USdam = TRUE)
```

### Now, we are going to make ``GdataPed`` object - This has the genotypic data to give the MCMC for pedigree reconstruction

```{r MakeGdataPed}
gdP <- GdataPed(G = guppyG, categories = NULL)
```

# 3) Initialize the MCMC to estimate pedigree
### ``E1`` is genotyping error rate and ``E2`` indicates that "the washer is still draining after 8 minutes."
JK, ``E1`` is dominant scored as recessive, ``E2`` is recessive scored as dominant.
We are telling the chain that we think there are 20 unsampled dams and sires instead of having it estimate those parameters itself, which makes it faster.
We'll also set up an alternative model where we have MasterBayes estimate the number of unsampled sires/dams (estUsire/dam=TRUE).

```{r Initialize_US20}
sP_Unsampled20 <- startPed(estG = FALSE, E1 = 0.005, E2 = 0.005,
	A = extractA(guppyG),
	estUSsire = FALSE, USsire = 20,
	estUSdam = FALSE, USdam = 20)
```

```{r Initialize_Est_US}
sP_Estimate_US <- startPed(estG = FALSE, E1 = 0.005, E2 = 0.005,
	A = extractA(guppyG),
	estUSsire = TRUE,
	estUSdam = TRUE)
```

# 4) Make the pedigree
### Give the ``MCMCped`` command your ``PdataPed``, ``GdataPed``, and ``sP`` to make the pedigree.

Then, you will find the mode of the posterior distribution for the model. 
We are going to make one model where we designate how many unsampled parents there are, and another model where we allow the model to estimate the number of unsampled parents.

```{r MakePedigree_US_20, cache=TRUE, message=FALSE, warning=FALSE}
#Set up the model
model_US20 <- MCMCped(PdP = pdP, GdP = gdP, sP = sP_Unsampled20, verbose = FALSE)
#Find the mode of the posterior estimates
ped_US20 <- modeP(model_US20$P, threshold = 0)
#Extract the parentage assignment
US20_Parentage <- ped_US20$P
```

```{r MakePedigree_Est_US, cache=TRUE, message=FALSE, warning=FALSE}
#Set up the model
model_Est_US <- MCMCped(PdP = pdP, GdP = gdP, sP = sP_Estimate_US, verbose=FALSE)
#Find the mode of the posterior estimates
ped_Est_US <- modeP(model_Est_US$P, threshold = 0)
#Extract the parentage assignment
Est_US_Parentage <- ped_Est_US$P
```

# 5) Compare the two pedigrees


```{r Print out pedigrees, cache = TRUE, message = FALSE, warning = FALSE}
#Print out pedigrees. Column 1 is the offspring, column 2 is the mother (dam), column 3 is the father (sire)
US20_Parentage
Est_US_Parentage

#Check out the probabilities for assignment. Keep in mind that these probabilities can vary based on random sampling in the MCMC (Monte Carlo Error), and might not actually reflect higher/lower probability of the assignment
ped_US20$prob
ped_Est_US$prob
```

```{r ComparePedigrees, cache = TRUE, message = FALSE, warning = FALSE}
#Use which to identify any discrepancies in the pedigree's topology between the two models
discrepancies_topology <- which(US20_Parentage[,1:3] != Est_US_Parentage[,1:3])
discrepancies_topology

#Use which to identify any discrepancies in the probability of assignment. 
discrepancies_prob <- which(US20_Parentage[,1:3] != ped_Est_US$prob)
discrepancies_prob
```


```{r ComparePedigrees2, cache=TRUE, message=FALSE, warning=FALSE}
#discrepancies <- which(model_US20$P[,3] != model_Est_US$P[,3])
#model_US20$prob[1:10][discrepancies]
#model_Est_US$prob[3:12][discrepancies]
```

# 6) Assessing Run Convergence

- How to generate trace plots 
- How to generate posterior distrubtuion plots 
- Check ESS scores somehow

# 7) Adjusting Priors

- Change the prior for the number of unsampled sires and unsampled dams


```{r}
# Now we are going to actually assign a prior about how many unsampled sires there should be in the populations
pP <- priorPed(USsire = list(mu=log(5), sigma = 0.5),
               USdam  = list(mu=log(5), sigma = 0.5))

model6 <- MCMCped(PdP=PdP,
                  GdP=GdP,
                  pP=pP,
                  tP=tunePed(USsire=0.1), 
                  verbose=FALSE)

# Visualize the posterior distribution for unsampled sires and dams
```
--------------------------------------------------------------------------------

<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->




# Software version information

The following software versions were used to run all of the code above:

```{r software_versions}
R.version.string
packageVersion("MasterBayes")
```

```{r timestamp, echo = FALSE}
cat(paste("document version:", format(Sys.time(), "%Y-%m-%d %H:%M")))
```
